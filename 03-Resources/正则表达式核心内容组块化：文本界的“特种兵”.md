嘿，朋友！想在文本的海洋里精准捕捞信息？想一键替换掉所有错别字？想验证用户输入的手机号是不是真的手机号？那你就需要请出我们今天的主角——**正则表达式**（Regular Expression，简称 Regex 或 Regexp）。

它就像文本处理界的“特种兵”，能用一套神秘的暗号（也就是模式）去执行各种复杂的搜索、匹配、替换任务。别看它长得有点“抽象派”，一旦掌握了核心组块，你会发现它简直是效率神器！

下面，咱们就一块一块地拆解它：

## 1. 基础匹配：字面值与元字符

想象一下，你是个侦探，要在茫茫人海中找一个叫“李华”的人。最直接的办法就是找“李华”这两个字。

- 字面值（Literal Characters）:
    
    最简单的匹配就是匹配它本身。比如，你想找字符串里的“cat”，那正则表达式就是cat。
    
    - **例子**：`hello` 会匹配字符串 "hello world" 中的 "hello"。
        
- 元字符（Metacharacters）:
    
    但有些字符比较特殊，它们有“超能力”，不再代表自己，而是代表一类字符或某种位置。它们是正则表达式的灵魂！
    
    - `.` (点): 匹配**任意一个**字符（除了换行符）。
        
        - **例子**：`h.t` 能匹配 "hat", "hot", "h!t" 等等。就像侦探说：“我要找一个姓H，名T，中间随便什么字的人。”
            
    - `\` (反斜杠): 转义字符。当你真的想匹配那些有“超能力”的元字符本身时，就得用它来“解除武装”。
        
        - **例子**：想匹配网址里的点（`.`），就得写成`\.`。因为`.`本身是匹配任意字符的。
            

## 2. 数量控制：量词（Quantifiers）

侦探找到了“李华”，但现在他想找“李华华”或者“好多好多华”怎么办？这就需要量词来控制字符出现的次数。

- `*` (星号): 匹配前面的字符**零次或多次**。
    
    - **例子**：`ab*c` 能匹配 "ac" (b 零次), "abc", "abbc", "abbbc" 等。
        
- `+` (加号): 匹配前面的字符**一次或多次**。
    
    - **例子**：`ab+c` 能匹配 "abc", "abbc", "abbbc" 等，但不能匹配 "ac" (因为 b 至少要出现一次)。
        
- `?` (问号): 匹配前面的字符**零次或一次**。
    
    - **例子**：`colou?r` 能匹配 "color" 和 "colour"。就像侦探说：“我要找一个姓Colo，后面跟一个U或者不跟U，最后是R的人。”
        
- `{n}`: 匹配前面的字符**恰好 n 次**。
    
    - **例子**：`a{3}` 匹配 "aaa"。
        
- `{n,}`: 匹配前面的字符**至少 n 次**。
    
    - **例子**：`a{2,}` 匹配 "aa", "aaa", "aaaa" 等。
        
- `{n,m}`: 匹配前面的字符**至少 n 次，至多 m 次**。
    
    - **例子**：`a{2,4}` 匹配 "aa", "aaa", "aaaa"。
        
- 贪婪与非贪婪（Greedy vs. Non-Greedy）:
    
    默认情况下，量词是“贪婪”的，会尽可能多地匹配。如果你想让它“懒惰”一点，尽可能少地匹配，就在量词后面加上?。
    
    - **例子**：`.*?` 匹配任意字符零次或多次，但尽可能少。
        
        - 字符串："<a>b</a>"
            
        - `/<.*>/` (贪婪) 会匹配 "<a>b</a>"
            
        - `/<.*?>/` (非贪婪) 会匹配 "<a>" 和 "</a>"
            

## 3. 字符集合：字符类（Character Classes）

侦探想找所有姓“李”的人，或者所有姓“王”的人，或者所有姓“张”的人。这时候，一个一个列举就太麻烦了。字符类就是干这个的！

- `[]` (方括号): 匹配方括号中**任意一个**字符。
    
    - **例子**：`[aeiou]` 匹配任意一个元音字母。
        
    - **范围**：`[a-z]` 匹配任意一个小写字母；`[0-9]` 匹配任意一个数字。
        
    - **排除**：`[^abc]` 匹配除了 'a', 'b', 'c' 之外的任意一个字符。`^`在方括号内表示“非”。
        
- 常用预定义字符类:
    
    这些是懒人福音，代表了常用的字符集合。
    
    - `\d`: 匹配任意一个**数字** (0-9)。等同于`[0-9]`。
        
    - `\D`: 匹配任意一个**非数字**字符。等同于`[^0-9]`。
        
    - `\w`: 匹配任意一个**单词字符** (字母、数字、下划线)。等同于`[a-zA-Z0-9_]`。
        
    - `\W`: 匹配任意一个**非单词字符**。等同于`[^a-zA-Z0-9_]`。
        
    - `\s`: 匹配任意一个**空白字符** (空格、制表符、换行符等)。
        
    - `\S`: 匹配任意一个**非空白字符**。
        

## 4. 位置限定：锚点（Anchors）

侦探想找“李华”这个人，但他必须是某个班级的第一个人，或者最后一个。锚点就是用来限定匹配位置的。

- `^` (脱字符): 匹配字符串的**开头**。
    
    - **例子**：`^Hello` 只能匹配以 "Hello" 开头的字符串。
        
- `$` (美元符号): 匹配字符串的**结尾**。
    
    - **例子**：`World$` 只能匹配以 "World" 结尾的字符串。
        
- `\b`: 匹配**单词边界**。一个单词的开头或结尾。
    
    - **例子**：`\bcat\b` 能匹配 "The cat sat" 中的 "cat"，但不会匹配 "category" 中的 "cat"。
        
- `\B`: 匹配**非单词边界**。
    
    - **例子**：`\Bcat\B` 能匹配 "category" 中的 "cat" (因为它不在单词边界)，但不会匹配 "The cat sat"。
        

## 5. 组合与捕获：分组（Groups and Capturing）

侦探想找“李华”和“王芳”这对情侣，并且想把他们的名字分别记录下来。分组就能实现这个功能。

- `()` (圆括号):
    
    1. **分组**: 将多个字符或模式组合成一个整体，可以对其应用量词。
        
        - **例子**：`(ab)+` 匹配 "ab", "abab", "ababab" 等。
            
    2. **捕获**: 捕获匹配到的子字符串，可以在后续操作中引用。
        
        - **例子**：`(\d{3})-(\d{4})` 匹配 "123-4567"，并捕获 "123" 和 "4567" 作为两个独立的组。
            
- `\n` (反向引用): 引用前面捕获的组。`\1`引用第一个组，`\2`引用第二个组，以此类推。
    
    - **例子**：`([a-z])\1` 匹配连续两个相同的小写字母，如 "aa", "bb"。
        
- `(?:...)` (非捕获分组): 只是分组，不捕获匹配内容。当你只想组合模式而不关心捕获时使用，可以提高性能。
    
    - **例子**：`(?:ab)+c` 匹配 "abc", "ababc" 等，但不会捕获 "ab"。
        

## 6. 选择：或（Alternation）

侦探想找“李华”或者“张三”。

- `|` (竖线): 匹配**或**关系，即匹配竖线两边的任意一个模式。
    
    - **例子**：`cat|dog` 匹配 "cat" 或 "dog"。
        
    - **例子**：`gr(a|e)y` 匹配 "gray" 或 "grey"。
        

## 7. 高级特性（了解即可）：零宽度断言（Lookarounds）

这些是正则表达式里的“黑科技”，它们匹配的是位置，不消耗字符，就像侦探在不移动脚步的情况下，判断周围有没有特定的东西。

- `(?=...)` (正向先行断言/Positive Lookahead): 匹配后面跟着`...`的位置。
    
    - **例子**：`\d+(?=美元)` 匹配后面跟着“美元”的数字，但“美元”本身不被匹配。
        
        - 字符串："我有100美元"
            
        - 匹配结果："100"
            
- `(?!...)` (负向先行断言/Negative Lookahead): 匹配后面**没有**跟着`...`的位置。
    
    - **例子**：`\d+(?!%)` 匹配后面**没有**跟着“%”的数字。
        
        - 字符串："100%，200元"
            
        - 匹配结果："200" (100后面跟着%，所以不匹配)
            
- `(?<=...)` (正向后行断言/Positive Lookbehind): 匹配前面是`...`的位置。
    
    - **例子**：`(?<=￥)\d+` 匹配前面是“￥”的数字。
        
        - 字符串："￥100，200"
            
        - 匹配结果："100"
            
- `(?<!...)` (负向后行断言/Negative Lookbehind): 匹配前面**不是**`...`的位置。
    
    - **例子**：`(?<!非)\d+` 匹配前面**不是**“非”的数字。
        
        - 字符串："非数字123，数字456"
            
        - 匹配结果："456"
            

## 8. 模式修饰符/标志（Flags/Modifiers）

这些是正则表达式的“开关”，可以改变匹配的行为。

- `i` (不区分大小写/Case-insensitive): 匹配时忽略大小写。
    
    - **例子**：`/hello/i` 能匹配 "Hello", "hello", "HELLO" 等。
        
- `g` (全局匹配/Global): 匹配所有符合条件的，而不是找到第一个就停止。
    
    - **例子**：`/cat/g` 在 "cat and dog and cat" 中会匹配两个 "cat"。
        
- `m` (多行模式/Multiline): 使`^`和`$`匹配每行的开头和结尾，而不仅仅是整个字符串的开头和结尾。
    

## 总结与实战建议

正则表达式就像一套精密的乐高积木，每个组块都有自己的功能，但它们组合起来就能创造无限可能。

- **核心思维**：
    
    1. **匹配什么**：用字面值、字符类。
        
    2. **匹配多少**：用量词。
        
    3. **匹配哪里**：用锚点。
        
    4. **如何组合**：用分组和或。
        
- **学习路径**：
    
    - **多练！** 找一个在线的正则表达式测试工具（比如 Regex101.com），边学边练，实时看效果。
        
    - **从小处着手**：先匹配简单的，再逐渐增加复杂度。
        
    - **善用查阅**：记住常用的元字符和量词，不常用的随时查阅。
        

掌握了这些核心组块，你就能在文本处理的世界里游刃有余，成为真正的“文本特种兵”！去吧，去征服那些复杂的字符串！